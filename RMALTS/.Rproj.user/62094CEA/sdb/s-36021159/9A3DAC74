{
    "collab_server" : "",
    "contents" : "self.epsilon = epsilon #lambda x: (1 + np.exp( - self.epsilon) )/(1+np.exp( self.gamma * (x - self.epsilon) ) )\n\nn <- nrow(data)\np <- ncol(data)-2 # self.n, self.p = data.shape # self.p = self.p - 2\n\ncontinuous <- colnames(data)-c(outcome, treatment, discrete) # self.continuous = set(data.columns).difference(set([outcome]+[treatment]+discrete))\n# #        Mc = np.ones((len(self.continuous),)) #initializing the stretch vector\n# #        Md = np.ones((len(self.discrete),)) #initializing the stretch vector\n\n# #splitting the data into control and treated units\ndf_T <- # self.df_T = data.loc[data[treatment]==1]\ndf_C <- # self.df_C = data.loc[data[treatment]==0]\n# #extracting relevant covariates (discrete,continuous)\n# #and outcome. Converting to numpy array.\nXc_T <- # self.Xc_T = self.df_T[self.continuous].to_numpy()\nXc_C <- # self.Xc_C = self.df_C[self.continuous].to_numpy()\nXd_T <- # self.Xd_T = self.df_T[self.discrete].to_numpy()\nXd_C <- # self.Xd_C = self.df_C[self.discrete].to_numpy()\nY_T <- # self.Y_T = self.df_T[self.outcome].to_numpy()\nY_C <- # self.Y_C = self.df_C[self.outcome].to_numpy()\ndel2_Y_T <- # self.del2_Y_T = ((np.ones((len(self.Y_T),len(self.Y_T)))*self.Y_T).T - (np.ones((len(self.Y_T),len(self.Y_T)))*self.Y_T))**2\ndel2_Y_C <- # self.del2_Y_C = ((np.ones((len(self.Y_C),len(self.Y_C)))*self.Y_C).T - (np.ones((len(self.Y_C),len(self.Y_C)))*self.Y_C))**2\n#\nDc_T <- # self.Dc_T = np.ones((self.Xc_T.shape[0],self.Xc_T.shape[1],self.Xc_T.shape[0])) * self.Xc_T.T\nDc_T <- # self.Dc_T = (self.Dc_T - self.Dc_T.T)\nDc_C <- # self.Dc_C = np.ones((self.Xc_C.shape[0],self.Xc_C.shape[1],self.Xc_C.shape[0])) * self.Xc_C.T\nDc_C <- # self.Dc_C = (self.Dc_C - self.Dc_C.T)\n#\nDd_T <- # self.Dd_T = np.ones((self.Xd_T.shape[0],self.Xd_T.shape[1],self.Xd_T.shape[0])) * self.Xd_T.T\nDd_T <- # self.Dd_T = (self.Dd_T != self.Dd_T.T)\nDd_C <- # self.Dd_C = np.ones((self.Xd_C.shape[0],self.Xd_C.shape[1],self.Xd_C.shape[0])) * self.Xd_C.T\nDd_C <- # self.Dd_C = (self.Dd_C != self.Dd_C.T)\n\n\nthreshold <- function(self,x){\n  #   k = self.k\n  # for i in range(x.shape[0]):\n  #   row = x[i,:]\n  # row1 = np.where( row < row[np.argpartition(row,k+1)[k+1]],1,0)\n  # x[i,:] = row1\n  # return x\n}\n\n\ndistance <- function(self,Mc,Md,xc1,xd1,xc2,xd2){\n  #   dc = np.dot((Mc**2)*(xc1-xc2),(xc1-xc2))\n  # dd = np.sum((Md**2)*xd1!=xd2)\n  # return dc+dd\n  #\n  # def loss_(self, Mc, Md, xc1, xd1, y1, xc2, xd2, y2, gamma=1 ):\n  #   w12 = np.exp( -1 * gamma * self.distance(Mc,Md,xc1,xd1,xc2,xd2) )\n  # return w12*((y1-y2)**2)\n}\n\n\ncalcW_T <- function(self,Mc,Md){\n  #   #this step is slow\n  Dc <- #   Dc = np.sum( ( self.Dc_T * (Mc.reshape(-1,1)) )**2, axis=1)\n  Dd <- # Dd = np.sum( ( self.Dd_T * (Md.reshape(-1,1)) )**2, axis=1)\n  W <- # W = self.threshold( (Dc + Dd) )\n  W <- # W = W / (np.sum(W,axis=1)-np.diag(W)).reshape(-1,1)\n  return(W) # return W\n}\n\n\ncalcW_C <- function(self,Mc,Md){\n  #   #this step is slow\n  Dc <- #   Dc = np.sum( ( self.Dc_C * (Mc.reshape(-1,1)) )**2, axis=1)\n  Dd <- # Dd = np.sum( ( self.Dd_C * (Md.reshape(-1,1)) )**2, axis=1)\n  W <- # W = self.threshold( (Dc + Dd) )\n  W <- # W = W / (np.sum(W,axis=1)-np.diag(W)).reshape(-1,1)\n  return(W) # return W\n}\n\nDelta_ <- function(self,Mc,Md){\n  W_T <- # self.W_T = self.calcW_T(Mc,Md)\n  W_C <- # self.W_C = self.calcW_C(Mc,Md)\n  delta_T <- # self.delta_T = np.sum((self.Y_T - (np.matmul(self.W_T,self.Y_T) - np.diag(self.W_T)*self.Y_T))**2)\n  delta_C <- # self.delta_C = np.sum((self.Y_C - (np.matmul(self.W_C,self.Y_C) - np.diag(self.W_C)*self.Y_C))**2)\n  return(delta_T + delta_C) # return self.delta_T + self.delta_C\n}\n\n\nobjective <- function(M){\n  # self.continuous = set(data.columns).difference(set([outcome]+[treatment]+discrete))\n  Mc <- subset(M,len(continuous)) # Mc = M[:len(self.continuous)]\n  Md <- M[len(continuous):] # Md = M[len(self.continuous):]\n  delta <- self.Delta_(Mc,Md) # delta = self.Delta_(Mc,Md)\n  reg <- self.C * ( np.linalg.norm(Mc,ord=2)**2 + np.linalg.norm(Md,ord=2)**2 ) # reg = self.C * ( np.linalg.norm(Mc,ord=2)**2 + np.linalg.norm(Md,ord=2)**2 )\n  cons1 <- 0 * ( (np.sum(Mc) + np.sum(Md)) - self.p )**2 # cons1 = 0 * ( (np.sum(Mc) + np.sum(Md)) - self.p )**2\n  cons2 <- 1e+25 * np.sum( ( np.concatenate((Mc, Md)) < 0 ) ) # cons2 = 1e+25 * np.sum( ( np.concatenate((Mc,Md)) < 0 ) )\n  return(delta + reg + cons1 + cons2) # return delta + reg + cons1 + cons2\n}\n\n\nfit <- function(method ='BFGS', data, objective){\n  p <- ncol(data)-2\n  M_init <- matrix(1,p,1)  #   M_init = np.ones((self.p,))\n  res <- optim(M_init, objective, method = method) # res <- opt.minimize( self.objective, x0=M_init,method=method )\n  M <- res.par # M = res.x\n  # Mc <- self.M[:len(self.continuous)]\n  # Md <- self.M[len(self.continuous):]\n  return(res) # return res\n}\n\n\n\n# def get_matched_groups(self, df_estimation, k=10 ):\n#   #units to be matched\n#   Xc = df_estimation[self.continuous].to_numpy()\n# Xd = df_estimation[self.discrete].to_numpy()\n# Y = df_estimation[self.outcome].to_numpy()\n# T = df_estimation[self.treatment].to_numpy()\n# #splitted estimation data for matching\n# df_T = df_estimation.loc[df_estimation[self.treatment]==1]\n# df_C = df_estimation.loc[df_estimation[self.treatment]==0]\n# #converting to numpy array\n# Xc_T = df_T[self.continuous].to_numpy()\n# Xc_C = df_C[self.continuous].to_numpy()\n# Xd_T = df_T[self.discrete].to_numpy()\n# Xd_C = df_C[self.discrete].to_numpy()\n# Y_T = df_T[self.outcome].to_numpy()\n# Y_C = df_C[self.outcome].to_numpy()\n# D_T = np.zeros((Y.shape[0],Y_T.shape[0]))\n# D_C = np.zeros((Y.shape[0],Y_C.shape[0]))\n# #distance_treated\n# Dc_T = (np.ones((Xc_T.shape[0],Xc.shape[1],Xc.shape[0])) * Xc.T - (np.ones((Xc.shape[0],Xc.shape[1],Xc_T.shape[0])) * Xc_T.T).T)\n# Dc_T = np.sum( (Dc_T * (self.Mc.reshape(-1,1)) )**2 , axis=1 )\n# Dd_T = (np.ones((Xd_T.shape[0],Xd.shape[1],Xd.shape[0])) * Xd.T != (np.ones((Xd.shape[0],Xd.shape[1],Xd_T.shape[0])) * Xd_T.T).T )\n# Dd_T = np.sum( (Dd_T * (self.Md.reshape(-1,1)) )**2 , axis=1 )\n# D_T = (Dc_T + Dd_T).T\n# #distance_control\n# Dc_C = (np.ones((Xc_C.shape[0],Xc.shape[1],Xc.shape[0])) * Xc.T - (np.ones((Xc.shape[0],Xc.shape[1],Xc_C.shape[0])) * Xc_C.T).T)\n# Dc_C = np.sum( (Dc_C * (self.Mc.reshape(-1,1)) )**2 , axis=1 )\n# Dd_C = (np.ones((Xd_C.shape[0],Xd.shape[1],Xd.shape[0])) * Xd.T != (np.ones((Xd.shape[0],Xd.shape[1],Xd_C.shape[0])) * Xd_C.T).T )\n# Dd_C = np.sum( (Dd_C * (self.Md.reshape(-1,1)) )**2 , axis=1 )\n# D_C = (Dc_C + Dd_C).T\n# MG = {}\n# for i in range(Y.shape[0]):\n#   #finding k closest control units to unit i\n#   idx = np.argpartition(D_C[i,:],k)\n# matched_Xc_C, matched_Xd_C, matched_Y_C, d_array_C = Xc_C[idx[:k],:], Xd_C[idx[:k],:], Y_C[idx[:k]], D_C[i,idx[:k]]\n# #finding k closest treated units to unit i\n# idx = np.argpartition(D_T[i,:],k)\n# matched_Xc_T, matched_Xd_T, matched_Y_T, d_array_T = Xc_T[idx[:k],:], Xd_T[idx[:k],:], Y_T[idx[:k]],D_T[i,idx[:k]]\n# MG[i] = {'unit':[ Xc[i], Xd[i], Y[i], T[i] ] ,'control':[ matched_Xc_C, matched_Xd_C, matched_Y_C, d_array_C],'treated':[matched_Xc_T, matched_Xd_T, matched_Y_T, d_array_T ]}\n# return MG\n#\n# def CATE(self,MG,outcome_discrete=False,model='linear'):\n#   cate = {}\n# for k,v in MG.items():\n#   #control\n#   matched_X_C = np.hstack((v['control'][0],v['control'][1]))\n# matched_Y_C = v['control'][2]\n# #treated\n# matched_X_T = np.hstack((v['treated'][0], v['treated'][1]))\n# matched_Y_T = v['treated'][2]\n# x = np.hstack(([v['unit'][0]], [v['unit'][1]]))\n# if not outcome_discrete:\n#   if model=='mean':\n#   yt = np.mean(matched_Y_T)\n# yc = np.mean(matched_Y_C)\n# cate[k] = {'CATE': yt - yc,'outcome':v['unit'][2],'treatment':v['unit'][3] }\n# if model=='linear':\n#   yc = lm.Ridge().fit( X = matched_X_C, y = matched_Y_C )\n# yt = lm.Ridge().fit( X = matched_X_T, y = matched_Y_T )\n# cate[k] = {'CATE': yt.predict(x) - yc.predict(x),'outcome':v['unit'][2],'treatment':v['unit'][3] }\n# if model=='RF':\n#   yc = ensemble.RandomForestRegressor().fit( X = matched_X_C, y = matched_Y_C )\n# yt = ensemble.RandomForestRegressor().fit( X = matched_X_T, y = matched_Y_T )\n# cate[k] = {'CATE': yt.predict(x)[0] - yc.predict(x)[0],'outcome':v['unit'][2],'treatment':v['unit'][3] }\n# return pd.DataFrame.from_dict(cate,orient='index')\n",
    "created" : 1581778398025.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2137167366",
    "id" : "9A3DAC74",
    "lastKnownWriteTime" : 1586091946,
    "last_content_update" : 1586091946495,
    "path" : "~/Desktop/Harsh/RMALTS/R/malts_Py.R",
    "project_path" : "R/malts_Py.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 4,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}